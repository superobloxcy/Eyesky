"""
Serial tracking handler that reads from ephemeris tracking logs.
Works with logs generated by ephemeris_gui.py
"""

import serial
import time
from pathlib import Path
from datetime import datetime
import pytz


class EphemerisSerialTracker:
    def __init__(self, serial_port="COM5", baud_rate=115200, log_file=None):
        """
        Initialize the serial tracker.
        
        Args:
            serial_port: COM port for ESP32
            baud_rate: Serial communication speed
            log_file: Path to tracking log file (uses latest if not specified)
        """
        self.serial_port = serial_port
        self.baud_rate = baud_rate
        self.ser = None
        self.connected = False
        self.log_file = log_file or self.find_latest_log()
        self.current_target = None
    
    def find_latest_log(self):
        """Find the most recently generated tracking log."""
        log_dir = Path('tracking_logs')
        if not log_dir.exists():
            return None
        
        log_files = list(log_dir.glob('tracking_log_*.txt'))
        if not log_files:
            return None
        
        latest = max(log_files, key=lambda p: p.stat().st_mtime)
        print(f"Using log file: {latest}")
        return str(latest)
    
    def connect(self):
        """Establish serial connection to ESP32."""
        if self.connected:
            return True
        
        print(f"Connecting to {self.serial_port} at {self.baud_rate} baud...")
        try:
            if self.ser:
                self.ser.close()
                time.sleep(1)
            
            self.ser = serial.Serial(self.serial_port, self.baud_rate, timeout=5)
            time.sleep(2)  # Wait for ESP32 initialization
            self.connected = True
            print("✓ Connected to ESP32")
            return True
        
        except (serial.SerialException, PermissionError, OSError) as e:
            print(f"✗ Failed to connect: {e}")
            self.connected = False
            return False
    
    def disconnect(self):
        """Safely close serial connection."""
        if self.ser:
            try:
                self.ser.close()
            except:
                pass
        self.connected = False
    
    def send_command(self, command):
        """Send command to ESP32."""
        if not self.connected:
            self.connect()
        
        if self.connected:
            try:
                self.ser.write((command + "\n").encode())
                print(f"---> {command}")
                time.sleep(0.1)
                return True
            except (serial.SerialException, OSError) as e:
                print(f"✗ Send failed: {e}")
                self.disconnect()
                return False
        
        return False
    
    def load_and_track(self):
        """Load tracking log and execute tracking commands."""
        if not self.log_file or not Path(self.log_file).exists():
            print(f"✗ Log file not found: {self.log_file}")
            return False
        
        print(f"\n{'='*60}")
        print(f"Tracking Log: {self.log_file}")
        print(f"{'='*60}\n")
        
        # Parse and organize log data by timestamp
        entries = {}  # unix_time -> list of (target, az, alt)
        
        try:
            with open(self.log_file, 'r') as f:
                lines = f.readlines()
            
            # Skip header lines (until we find the data column line)
            data_start = 0
            for i, line in enumerate(lines):
                if 'Unix_Time' in line and 'DateTime_UTC' in line:
                    data_start = i + 1
                    break
            
            # Parse data lines
            for line in lines[data_start:]:
                line = line.strip()
                if not line or line.startswith('-'):
                    continue
                
                parts = [p.strip() for p in line.split(',')]
                if len(parts) >= 5:
                    try:
                        unix_time = int(parts[0])
                        datetime_str = parts[1]
                        target = parts[2]
                        az = float(parts[3])
                        alt = float(parts[4])
                        
                        if unix_time not in entries:
                            entries[unix_time] = []
                        entries[unix_time].append((target, az, alt))
                    except (ValueError, IndexError):
                        continue
            
            print(f"Loaded {len(entries)} tracking timesteps\n")
            
        except Exception as e:
            print(f"✗ Error parsing log file: {e}")
            return False
        
        # Connect and start tracking
        if not self.connect():
            return False
        
        print("Starting tracking loop (Press Ctrl+C to stop)...\n")
        
        try:
            while True:
                current_sec = int(time.time())
                
                if current_sec in entries:
                    for target, az, alt in entries[current_sec]:
                        cmd = f"AZ:{az:.4f} ALT:{alt:.4f}"
                        self.send_command(cmd)
                        
                        # Update current target for display
                        if target != self.current_target:
                            self.current_target = target
                            print(f"\n→ Now tracking: {target}")
                
                time.sleep(1)
        
        except KeyboardInterrupt:
            print("\n\nTracking stopped by user.")
        
        finally:
            self.disconnect()
        
        return True


def main():
    """Example usage."""
    import argparse
    
    parser = argparse.ArgumentParser(description='Track celestial objects via serial')
    parser.add_argument('--port', default='COM5', help='Serial port (default: COM5)')
    parser.add_argument('--baud', type=int, default=115200, help='Baud rate (default: 115200)')
    parser.add_argument('--log', help='Path to tracking log file (uses latest if not specified)')
    
    args = parser.parse_args()
    
    tracker = EphemerisSerialTracker(args.port, args.baud, args.log)
    tracker.load_and_track()


if __name__ == "__main__":
    main()
